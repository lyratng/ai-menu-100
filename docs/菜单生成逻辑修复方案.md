# 菜单生成逻辑修复方案

## 一、当前问题分析

### 1.1 菜品检索逻辑问题

**PRD要求**：
```
4种菜品类型 × 8种食材特征 × 12种刀工 = 384种细分标签
每种检索10道菜 → 最多3840道菜
```

**4种菜品类型**：
- 热菜主荤
- 热菜半荤
- 热菜素菜
- 凉菜

**8种食材特征**（仅热菜）：
- 肉、禽、鱼、蛋、豆、菌、筋、蔬

**12种刀工**：
- 片、丁、粒、米、末、茸、丝、条、段、块、球、花刀

**当前实现**：
```typescript
// ❌ 问题：只是简单随机取所有菜，没有按384标签分类检索
async function fetchAllAvailableDishes(storeId, historyRatio) {
  // 从专属菜库随机取
  // 从通用菜库随机取
  return allDishes;
}
```

**问题**：
1. 没有按照"菜品类型×食材×刀工"的384种组合检索
2. 没有每种组合检索10道菜
3. 随机性不足，可能导致某些组合的菜品被忽略

---

### 1.2 Prompt生成问题

**PRD要求**：
- 生成**一周5天**的菜单（monday - friday）
- 包含**9条完整开菜规则**
- 传递**完整的菜品信息**（菜名+8个标签）

**当前实现**：
```typescript
// ❌ 问题：临时简化版，只生成1天
const systemPrompt = `生成一天的午餐菜谱`;

// ❌ 问题：只传15道菜名，没有标签信息
const dishNames = dishes.slice(0, 15).map(d => d.dish_name);
```

**问题**：
1. 只生成周一（monday），缺少周二到周五
2. Prompt极度简化，缺少9条开菜规则
3. 只传菜名，缺少菜品标签信息（食材、刀工、烹饪方式等）
4. 菜品数量远不足（15 vs 3840）

---

## 二、修复方案

### 2.1 实现384种细分标签检索

```typescript
/**
 * 按照384种细分标签检索菜品
 * 4种菜品类型 × 8种食材 × 12种刀工 = 384种
 * 每种检索10道（或更少如果数据不足）
 */
async function fetch384TagDishes(
  storeId: string,
  historyRatio: number
): Promise<any[]> {
  const dishTypes = ['热菜主荤', '热菜半荤', '热菜素菜', '凉菜'];
  const ingredients = ['肉', '禽', '鱼', '蛋', '豆', '菌', '筋', '蔬'];
  const knifeSkills = ['片', '丁', '粒', '米', '末', '茸', '丝', '条', '段', '块', '球', '花刀'];
  
  const allDishes: any[] = [];
  const perTagCount = 10; // 每种标签检索10道菜
  
  for (const dishType of dishTypes) {
    for (const ingredient of ingredients) {
      for (const knife of knifeSkills) {
        // 从专属菜库检索
        const storeCount = Math.round(perTagCount * historyRatio);
        if (storeCount > 0) {
          const storeDishes = await query(
            `SELECT * FROM dishes_store 
             WHERE store_id = $1 
             AND dish_type = $2 
             AND $3 = ANY(ingredient_tags)
             AND knife_skill = $4
             AND is_active = TRUE
             ORDER BY RANDOM()
             LIMIT $5`,
            [storeId, dishType, ingredient, knife, storeCount]
          );
          allDishes.push(...storeDishes.rows);
        }
        
        // 从通用菜库检索
        const commonCount = perTagCount - storeCount;
        if (commonCount > 0) {
          const commonDishes = await query(
            `SELECT * FROM dishes_common 
             WHERE dish_type = $1 
             AND $2 = ANY(ingredient_tags)
             AND knife_skill = $3
             AND is_active = TRUE
             ORDER BY RANDOM()
             LIMIT $4`,
            [dishType, ingredient, knife, commonCount]
          );
          allDishes.push(...commonDishes.rows);
        }
      }
    }
  }
  
  return allDishes;
}
```

**优化考虑**：
- 384次数据库查询可能较慢，可以考虑：
  1. 使用批量查询+内存过滤
  2. 添加缓存层
  3. 使用并发查询（Promise.all分批）

---

### 2.2 构建完整的5天菜单Prompt

```typescript
function buildMenuGenerationPrompt(
  request: GenerateMenuRequest,
  dishes: any[]
): { systemPrompt: string; userPrompt: string } {
  
  // System Prompt - 完整版
  const systemPrompt = `你是一位在中国团餐行业工作多年的经验丰富的厨师长。请严格按照以下【开菜规则】，为团餐食堂生成一周五天的午餐菜谱。

【重要】菜名使用规则：
你必须严格使用下文【菜品来源】中提供的菜名，不得自行创造或修改菜名。输出的菜名必须与菜品来源中的某一道菜完全一致（逐字匹配）。如果菜品来源中没有合适的菜，优先调整其他约束条件，而不是修改菜名。

【开菜规则】：
1. 设备可实现性：可以使用的烹饪方式是【${request.cook_method8_available.join('、')}】，严禁出现其他烹饪方式的菜
2. 成本控制：一餐避免重复出现高成本食材/菜品，如水产品、牛羊肉
3. 食材多样性：一餐内，主要食材不得重复（例如：鸡翅、鸡腿、鸡胸、鸡爪是不同食材）
4. 原材料多样性：${getIngredientDiversityRequirement(request.ingredient_diversity_requirement)}
5. 辣味菜数量要求：${getSpicyRequirement(request.spicy_level)}
6. 刀工多样性：${getKnifeSkillRequirement(request.staffing_tight)}
7. 调味品多样性：${getFlavorRequirement(request.flavor_diversity_required)}
8. 烹饪方式多样性：每周菜单必须出现炒、熘、蒸、烧、烤、炖、煎、烹8种烹饪方法中的至少六种
9. 口感多样性：一餐不要出现超过两个勾芡菜

【输出要求】：
严格按照JSON格式输出，包含周一到周五的菜单：
{
  "monday": [
    {
      "name": "菜品名称（从菜品来源选择，不含分类标签）",
      "description": "菜品的简介，约50-100字，包括菜品特色、口感、营养价值等",
      "cookingMethod": "烹饪步骤，描述性质，50-100字"
    }
  ],
  "tuesday": [...],
  "wednesday": [...],
  "thursday": [...],
  "friday": [...]
}`;

  // User Prompt - 包含完整菜品信息
  const dishesInfo = formatDishesForPrompt(dishes);
  
  const userPrompt = `请从以下【菜品来源】中选取菜品，为团餐食堂生成一周五天的午餐菜谱。

【每日菜品要求】：
- 每天包含 ${request.hot_dish_total_per_day} 个热菜和 ${request.cold_per_day} 个凉菜
- 热菜中：${request.main_meat_per_day} 个主荤菜、${request.half_meat_per_day} 个半荤菜、${request.veggie_hot_per_day} 个素菜

【菜品来源】：
${dishesInfo}

请严格按照JSON格式输出一周五天的完整菜单。`;

  return { systemPrompt, userPrompt };
}
```

---

### 2.3 格式化菜品信息

```typescript
/**
 * 将菜品格式化为适合Prompt的字符串
 * 包含菜名和关键标签信息
 */
function formatDishesForPrompt(dishes: any[]): string {
  // 按菜品类型分组
  const grouped: Record<string, any[]> = {
    '热菜主荤': [],
    '热菜半荤': [],
    '热菜素菜': [],
    '凉菜': []
  };
  
  dishes.forEach(dish => {
    if (grouped[dish.dish_type]) {
      grouped[dish.dish_type].push(dish);
    }
  });
  
  let result = '';
  
  for (const [type, typeDishes] of Object.entries(grouped)) {
    if (typeDishes.length === 0) continue;
    
    result += `\n【${type}】（共${typeDishes.length}道）：\n`;
    
    // 格式：菜名｜食材：xxx｜刀工：xxx｜烹饪：xxx｜口味：xxx
    typeDishes.forEach((dish, idx) => {
      const tags = [
        `食材:${(dish.ingredient_tags || []).join(',')}`,
        `刀工:${dish.knife_skill || '未知'}`,
        `烹饪:${dish.cook_method8 || '炒'}`,
        dish.flavor ? `口味:${dish.flavor}` : null
      ].filter(Boolean).join(' | ');
      
      result += `${idx + 1}. ${dish.dish_name}（${tags}）\n`;
    });
  }
  
  return result;
}
```

---

## 三、实施步骤

### 步骤1：实现384标签检索函数（复杂度高）

**预计时间**：30-60分钟
**风险**：384次数据库查询可能较慢

**优化方案**：
- 先实现基础版（顺序查询）
- 后续优化（批量查询+内存过滤）

### 步骤2：修复Prompt生成逻辑

**预计时间**：20-30分钟
**关键点**：
- 生成5天完整菜单结构
- 添加9条完整规则
- 格式化菜品信息

### 步骤3：调整AI响应解析

**预计时间**：10-15分钟
**关键点**：
- 解析5天的菜单数据（monday-friday）
- 确保每天都有数据

### 步骤4：测试与优化

**预计时间**：30-60分钟
**关键点**：
- 测试完整流程
- 检查生成的5天菜单
- 优化性能（如果太慢）

---

## 四、性能优化建议

### 4.1 批量查询优化

**问题**：384次独立查询太慢

**优化方案**：
```typescript
// 方案1：一次性取所有菜，然后在内存中按384标签分组
async function fetch384TagDishesFast(storeId, historyRatio) {
  // 1. 一次性查询所有菜品
  const allCommonDishes = await query(
    'SELECT * FROM dishes_common WHERE is_active = TRUE'
  );
  
  // 2. 在内存中按384种组合分组
  const grouped = groupBy384Tags(allCommonDishes.rows);
  
  // 3. 每种组合随机取10道
  const result = [];
  for (const [tagKey, dishes] of Object.entries(grouped)) {
    result.push(...shuffleAndTake(dishes, 10));
  }
  
  return result;
}
```

### 4.2 渐进式实现

**阶段1**：简化版（不按384标签）
- 只按菜品类型分组（4种）
- 快速验证Prompt和5天生成逻辑

**阶段2**：完整版（按384标签）
- 实现完整的384标签检索
- 优化查询性能

---

## 五、立即可执行的修复代码

见下方实际代码修改。

